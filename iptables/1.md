# Iptables概述

Iptables是一个Linux的防火墙，所有IP数据报在进入到主机的时候，都会先经历Iptables的筛选。Iptables一般需要Linux内核进行支持，通常来说是使用Xtables这个内核模块。

当收到一个数据报时，Iptables可以根据预先定义好的规则，以决定是否**接受(Accept)**、**拒绝(Reject)**或**丢弃(Drop)**数据报。此外，还可以根据数据报的时机进行判断，包括（后面会有更详细的说明，这里简单理解一下就好）：
1. 进行路由选择前(**PreRouting**);
2. 数据包进入时(**Input**);
3. 决定进行数据报转发时(**Forwarding**);
4. 数据包外出时(**Output**);
5. 路由选择完成后(**PostRouting**).

看到这里有同学就会发现，之前用的Nginx也可以做到流量转发。例如可以开一个MySQL服务监听3306端口，然后Nginx服务监听13306端口，将TCP流量通过Stream的方式进行转发，客户端访问13306端口就可以做到访问内网的3306端口。Nginx也可以做到IP的白名单/黑名单功能。那么为什么要用Iptables呢？

针对这个问题，我的理解是，对TCP进行反向代理的代价太大。首先，Nginx需要维护两条TCP连接（一条TCP连接客户端，一条TCP连接服务端，利用内存做缓冲区），约等于消耗的资源翻倍。此外，Nginx是应用层/传输层转发，而如果你想让Nginx去拒绝ICMP报文（网络层）是做不到的。

相反，Iptables可以控制网络层的数据包，即可以直接修改IP报文(消耗CPU资源)。并且由于IP报文含有"下一个协议(**Protocol**)"，常用的有TCP/UDP/ICMP等，Iptables也可以识别这个字段来进行处理。但是你想让Iptables帮你处理hostname识别、ssl证书等什么的是不可能的，这是应用层的东西，请交给Nginx等反向代理完成。

接下来，我们来看一下IP数据报文(IPv4)的详细格式：

![IPv4数据报文](./images/IPv4_Packet-en.svg)

> IPv6也大同小异

从理论上来说，报文中的所有字段，Iptables都有能力进行修改，以达到路由的效果。

看到这里你应该对Iptables有个大致的了解了。下一节将会搭建一些简单的实验环境来实际使用Iptables。
